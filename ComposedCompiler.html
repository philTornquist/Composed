<html>
    <head>
    	<title>Composed</title>
    </head>
    <body>
        <table>
            <tr>  
                <td>
                  <table>
                    <tr>
                    <td>
                        <button id="runButton" onclick="clickedRun()">Run</button>
                    </td>
                    </tr>
                    <tr>
                    <td>
                        <label><input type="checkbox" id="logExecution" value="value">Log Execution</label>
                    </td>
                    </tr>
                    <tr>
                    <td>
                        <label><input type="checkbox" id="logJITTING" value="value">Log JIT</label>
                    </td>
                    </tr>
                    <tr>
                    <td>
                        <label><input type="checkbox" id="logRestructure" value="value">Log Generic Creation</label>
                    </td>
                    </tr>
                  </table>
                </td>
                <td>
                 <textarea id="output" rows=30 cols=100>
</textarea>
            </tr>
        </table>
    <div>

        <textarea id="code" rows=50 cols=100>
Test_Parser'Literal' = Parser'Literal',Parser'Number' [123,"Test Type_"]:
Test_ParseClearWhite' = Parser'ClearedWhite',Parser'Literal' [[T,[e,[s,[t,Nothing]]]],[ ,[T,[y,[p,[e,[_,Nothing]]]]]]][[T,[e,[s,[t,Nothing]]]],[ ,[T,[y,[p,[e,[_,Nothing]]]]]]]:
    
SourceText is String
[A]Parser is [A], SourceText    
    
Character from [A]Parser(p):
    p > SourceText > String > Character
    
[A]Parser from [A](a), [B]Parser(p):
    [
        a,
        p > SourceText
    ] > [A]Parser
    
[A]NextParser is [A]Parser:   
    [
        value > SourceText > String > Substring > String > SourceText,
        value > [A]
    ] > [A]Parser


        
Literal is String
Parser'Literal' from [A]Parser(p):
    [
        Nothing > Literal,
        p
    ] > Parser'Literal' > Parser'Literal'

Parser'Literal' from Parser'Literal'(p):
    p > IsLiteralTerminator > Bit > Test'Parser'Literal'' {
        false:
            [
                [
                    p > Character,
                    p > Literal > String
                ] > AppendedString > String > Literal,
                p > NextParser'Literal' > Parser'Literal'
            ] > Parser'Literal' > Parser'Literal'
        true: p
    } > Parser'Literal'

ClearedWhite is Number
Parser'ClearedWhite' from [A]Parser(p):
    p > IsWhiteSpace > Bit > Test'Parser'ClearedWhite''{
        true:
            p > [A]NextParser > [A]Parser > Parser'ClearedWhite'
        false:
            [
                p,
                12345 > ClearedWhite
            ] > Parser'ClearedWhite'
    } > Parser'ClearedWhite'

DataType is GenericType, SubType
SubType is Literal, SubType
GenericType is Literal

Parser'DataType' from [A]Parser(p):
    [
        [
            [
                p > Parser'Literal' > Literal,
                p > Parser'Literal' > Parser'SubType' > SubType
            ] > SubType,
            Nothing > GenericType
        ] > DataType,
        p > Parser'Literal' > Parser'SubType'
    ] > Parser'DataType'

Parser'SubType' from [A]Parser(p):
    p > Parser'ClearedWhite' > IsQuote > Bit > Test'Parser'SubType'' {
        false:
            [
                Nothing > SubType,
                p
            ] > Parser'SubType'
        true:
            [
                [
                    p > Parser'ClearedWhite' > NextParser'ClearedWhite' > Parser'ClearedWhite' > Parser'Literal' > Literal,
                    p > Parser'ClearedWhite' > NextParser'ClearedWhite' > Parser'ClearedWhite' > Parser'Literal' > Parser'SubType' > SubType
                ] > SubType,
                p > Parser'ClearedWhite' > NextParser'ClearedWhite' > Parser'ClearedWhite' > Parser'Literal' > Parser'SubType'
            ] > Parser'SubType'
    } > Parser'SubType'

Parser'GenericType' from [A]Parser(p):
    p > Parser'ClearedWhite' > IsOpenSquareBrace > Bit > Test'Parser'GenericType'



IsLiteralTerminator is Bit
IsLiteralTerminator from [A]Parser(p):
    [
        [
            p > IsWhiteSpace > Bit,
            ["_", p > Character] > CompareBit > Bit
        ] > BitOr > Bit,
        p > IsQuote > Bit
    ] > BitOr > Bit > IsLiteralTerminator

IsWhiteSpace is Bit
IsWhiteSpace from [A]Parser(p):
    [" ", p > Character] > CompareBit > Bit > IsWhiteSpace

IsQuote is Bit
IsQuote from [A]Parser(p):
    ["'", p > Character] > CompareBit > Bit > IsQuote

CompareBit is Bit
CompareBit from Character(c1), Character(c2):
    [c1, c2] > Compare'Bit' {equal:1 less:0 greater:0} > Bit > CompareBit

IsOpenSquareBrace is Bit
IsOpenSquareBrace from [A]Parser(p):
    ["[", p > Character] > CompareBit > Bit > IsOpenSquareBrace
</textarea>
<textarea id="inputBytecode" rows=50 cols=100>
Conversion>Number,Sum
Element>0
Param>0
Extract>0

Conversion>Sum,Number
Data Structure>1

Conversion>Sum,Number,Number
ENTER>
IGNORE>(
Param>0
IGNORE> + 
Param>1
IGNORE>)
EXIT>

Conversion>Number,Difference
Element>0
Param>0
Extract>0

Conversion>Difference,Number
Data Structure>1

Conversion>Difference,Number,Number
ENTER>
IGNORE>(
Param>0
IGNORE> - 
Param>1
IGNORE>)
EXIT>

Conversion>Quotient,Number
Data Structure>1

Conversion>Number,Quotient
Element>0
Param>0
Extract>0

Conversion>Quotient,Number,Number
ENTER>
IGNORE>(
Param>0
IGNORE> / 
Param>1
IGNORE>)
EXIT>

Conversion>Modulus,Number
Data Structure>1

Conversion>Number,Modulus
Element>0
Param>0
Extract>0

Conversion>Modulus,Number,Number
ENTER>
IGNORE>(
Param>0
IGNORE> % 
Param>1
IGNORE>)
EXIT>

Conversion>Product,Number
Data Structure>1

Conversion>Number,Product
Element>0
Param>0
Extract>0

Conversion>Product,Number,Number
ENTER>
IGNORE>(
Param>0
IGNORE> * 
Param>1
IGNORE>)
EXIT>

Conversion>Number,Square
Element>0
Param>0
Extract>0

Specification>Square,Number
ENTER>
IGNORE>(
Param>0
IGNORE> * 
Param>0
IGNORE>)
EXIT>

Conversion>Number,SquareRoot
Element>0
Param>0
Extract>0

Specification>SquareRoot,Number
ENTER>
IGNORE>Math.sqrt(
Param>0
IGNORE>)
EXIT>



Conversion>[A],Nothing
Nothing>


Conversion>[A]Compare,[A]
Data Structure>1

Conversion>[A],[A]Compare
Element>0
Param>0
Extract>0

Conversion>[A]Compare,Character,Character
ENTER
Param>0
IGNORE> < 
Param>1
IGNORE> ? 
Ask>less
IGNORE> : (
Param>0
IGNORE> == 
Param>1
IGNORE> ? 
Ask>equal
IGNORE> : 
Ask>greater
IGNORE>)
EXIT>

Conversion>[A]Compare,Number,Number
ENTER>
Param>0
IGNORE> < 
Param>1
IGNORE> ? 
Ask>less
IGNORE> : (
Param>0
IGNORE> == 
Param>1
IGNORE> ? 
Ask>equal
IGNORE> : 
Ask>greater
IGNORE>)
EXIT>

Conversion>[A],[A]Exists
Element>0
Param>0
Extract>0

Specification>[B]Exists,[A]
ENTER>
IGNORE>(
Param>0
IGNORE> !== "Nothing" ? 
Ask>yes
IGNORE> : 
Ask>no
IGNORE>)
EXIT>

</textarea>
<textarea id="bytecode" rows=50 cols=100></textarea>
<textarea id="jsCode" rows=50 cols=100></textarea>
    </div>
    
    <script src="Library/List.cps.js"></script>
    <script src="Library/Bool.cps.js"></script>
    <script src="Library/String.cps.js"></script>

    <script src="LogHistory.js"></script>
    <script src="ConversionUtils.js"></script>
    <script src="Pseudocode.js"></script>

    <script src="Compiler.js"></script>
    <script src="Optimize.js"></script>

    <script src="Linker.js"></script>
    <script src="JSCompiler.js"></script>

<script>
    window.onload = function()
    {
        document.getElementById("code").value += List_CPS + String_CPS + Bool_CPS;
    }
    
    function clickedRun()
    {
        log_js_execution = document.getElementById("logExecution").checked ? LOG : NLOG;
        log_linker_restructure = document.getElementById("logRestructure").checked ? LOG : NLOG;
        log_jitting = document.getElementById("logJITTING").checked ? LOG : NLOG;
        log_js_compilation = log_jitting;
    
        var code = document.getElementById("code").value;
        document.getElementById("output").value = "";
        
        Data = new DataStore();
        Data.JITName = js_conversion_rename;
        
        var conversions = compile(code);
        load_pseudocode(Data, conversions);
        load_pseudocode(Data, document.getElementById("inputBytecode").value);
        
        
        document.getElementById("bytecode").value = conversions;
        document.getElementById("jsCode").value = "";
        
        link_conversions(Data);
        
        
        var missingMsg = "";
        for (var key in Data.Missing)
            missingMsg += key + "\n";
            
          
        if (missingMsg == "")
            run_inline();
        else
            alert("Missing the following conversions:\n" + missingMsg)
    }
</script>

    </body>
</html>
